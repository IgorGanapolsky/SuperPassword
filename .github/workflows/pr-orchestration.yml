name: ðŸ¤– PR Orchestration

on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review]
  pull_request_review:
    types: [submitted]
  check_suite:
    types: [completed]
  schedule:
    - cron: "*/15 * * * *"  # Run every 15 minutes
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  checks: write
  statuses: write

jobs:
  orchestrate:
    name: ðŸŽ¯ Orchestrate PRs
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Analyze PR State
        id: analyze
        uses: actions/github-script@v7
        with:
          script: |
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              sort: 'updated',
              direction: 'desc'
            });

            const prData = await Promise.all(prs.map(async pr => {
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });

              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });

              return {
                number: pr.number,
                title: pr.title,
                baseBranch: pr.base.ref,
                headBranch: pr.head.ref,
                draft: pr.draft,
                mergeable: pr.mergeable,
                reviews: reviews.map(r => ({ state: r.state, user: r.user.login })),
                checks: checks.check_runs.map(c => ({ name: c.name, conclusion: c.conclusion }))
              };
            }));

            // Analyze dependencies between PRs
            const dependencyGraph = prData.map(pr => {
              const depMatch = pr.title.match(/depends on #(\d+)/i);
              return {
                ...pr,
                dependsOn: depMatch ? parseInt(depMatch[1]) : null
              };
            });

            // Sort PRs by dependency order
            const sortedPRs = [...dependencyGraph].sort((a, b) => {
              if (a.dependsOn === b.number) return 1;
              if (b.dependsOn === a.number) return -1;
              return 0;
            });

            core.setOutput('prs', JSON.stringify(sortedPRs));

      - name: Process PRs
        uses: actions/github-script@v7
        with:
          script: |
            const prs = JSON.parse(process.env.PRS);
            
            for (const pr of prs) {
              console.log(`Processing PR #${pr.number}: ${pr.title}`);

              // Skip if PR is a draft
              if (pr.draft) {
                console.log('PR is draft - skipping');
                continue;
              }

              // Check dependencies
              if (pr.dependsOn) {
                const depPR = prs.find(p => p.number === pr.dependsOn);
                if (depPR && !depPR.merged) {
                  console.log(`Waiting for dependency PR #${pr.dependsOn}`);
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    body: `â³ This PR is blocked by #${pr.dependsOn}`
                  });
                  continue;
                }
              }

              // Check CI status
              const failingChecks = pr.checks.filter(c => c.conclusion === 'failure');
              if (failingChecks.length > 0) {
                console.log('CI checks failing - skipping');
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  body: `âŒ CI checks failing:\n${failingChecks.map(c => `- ${c.name}`).join('\n')}`
                });
                continue;
              }

              // Check reviews
              const approvals = pr.reviews.filter(r => r.state === 'APPROVED').length;
              if (approvals < 1) {
                console.log('Needs review - requesting');
                await github.rest.pulls.requestReviewers({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  reviewers: ['IgorGanapolsky']
                });
                continue;
              }

              // All checks passed - merge PR
              if (pr.mergeable) {
                console.log('All checks passed - merging');
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  merge_method: 'squash'
                });

                // If this was a PR to develop, create PR to main
                if (pr.baseBranch === 'develop') {
                  await github.rest.pulls.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: `chore(release): sync main with develop`,
                    body: `This PR syncs main with the latest changes from develop.\n\nOriginal PR: #${pr.number}`,
                    head: 'develop',
                    base: 'main'
                  });
                }
              }
            }
        env:
          PRS: ${{ steps.analyze.outputs.prs }}

  update-status:
    name: ðŸ“Š Update Status
    needs: orchestrate
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Update Status Board
        uses: actions/github-script@v7
        with:
          script: |
            const { data: issues } = await github.rest.issues.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'status-board'
            });

            const statusBoard = issues[0] || await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'ðŸ“Š PR Status Board',
              labels: ['status-board'],
              body: 'Initializing status board...'
            });

            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });

            const statusEmoji = {
              draft: 'ðŸ“',
              blocked: 'â³',
              failed: 'âŒ',
              ready: 'âœ…'
            };

            const prStatus = await Promise.all(prs.map(async pr => {
              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });

              let status = pr.draft ? 'draft' :
                          pr.title.match(/depends on #\d+/i) ? 'blocked' :
                          checks.check_runs.some(c => c.conclusion === 'failure') ? 'failed' :
                          'ready';

              return `${statusEmoji[status]} #${pr.number} ${pr.title}`;
            }));

            const body = `# ðŸ“Š PR Status Board
Last updated: ${new Date().toISOString()}

## Open PRs
${prStatus.join('\n')}

## Recent Activity
${prs.slice(0, 5).map(pr => `- ${pr.updated_at}: ${pr.title}`).join('\n')}
`;

            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: statusBoard.number,
              body
            });
