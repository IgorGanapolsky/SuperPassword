name: 🤖 PR Automation

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  check_suite:
    types: [completed]
  issue_comment:
    types: [created]
  status:
    types: [success]

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read
  statuses: read

jobs:
  auto-merge-dependabot:
    if: |
      (github.event_name == 'pull_request' && github.actor == 'dependabot[bot]') ||
      (github.event_name == 'status' && github.event.context == 'ci')
    runs-on: ubuntu-latest
    steps:
      - name: Auto-approve and merge Dependabot PRs
        uses: fastify/github-action-merge-dependabot@v3
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          target: minor
          merge-method: squash

  process-commands:
    if: |
      github.event_name == 'issue_comment' &&
      github.event.issue.pull_request &&
      contains(fromJson('["OWNER", "COLLABORATOR"]'), github.event.comment.author_association)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment.body.toLowerCase().trim();
            const pr = context.payload.issue.number;
            const user = context.payload.comment.user.login;

            const commands = {
              '/update': async () => {
                await github.rest.pulls.updateBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr
                });
                return '🔄 Updating PR with latest changes...';
              },
              '/merge': async () => {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr,
                  merge_method: 'squash'
                });
                return '✅ PR merged successfully!';
              },
              '/rerun': async () => {
                const runs = await github.rest.actions.listWorkflowRunsForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  status: 'failure'
                });
                
                for (const run of runs.data.workflow_runs) {
                  await github.rest.actions.reRunWorkflowFailedJobs({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: run.id
                  });
                }
                return '🔄 Rerunning failed checks...';
              }
            };

            for (const [cmd, action] of Object.entries(commands)) {
              if (comment.startsWith(cmd)) {
                try {
                  const message = await action();
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr,
                    body: `${message}\n\nTriggered by @${user}`
                  });
                } catch (error) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr,
                    body: `❌ Failed to execute ${cmd}:\n\`\`\`\n${error.message}\n\`\`\``
                  });
                }
                break;
              }
            }

  auto-merge:
    if: |
      github.event_name == 'check_suite' &&
      github.event.check_suite.conclusion == 'success' &&
      !github.event.repository.fork
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;

            // Find PR associated with this check suite
            const prs = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              head: context.sha
            });

            if (prs.data.length === 0) return;
            const pr = prs.data[0];

            // Only proceed if PR is ready and has no conflicts
            if (pr.draft || !pr.mergeable) return;

            // Check all required status checks
            const checks = await github.rest.checks.listForRef({
              owner,
              repo,
              ref: pr.head.sha
            });

            const allChecksPass = checks.data.check_runs.every(check =>
              check.status === 'completed' && check.conclusion === 'success'
            );

            if (allChecksPass) {
              try {
                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: pr.number,
                  merge_method: 'squash'
                });
                
                console.log(`Successfully merged PR #${pr.number}`);
              } catch (error) {
                console.error(`Failed to merge PR #${pr.number}:`, error);
              }
            }
