name: Autonomous Guardian System

on:
  schedule:
    - cron: '0 */2 * * *'  # Every 2 hours
  workflow_dispatch:
    inputs:
      mode:
        description: 'Operation mode'
        required: false
        type: choice
        default: 'monitor'
        options:
          - monitor
          - repair
          - emergency
          - reset

env:
  GUARDIAN_VERSION: '2.0.0'
  AUTO_REPAIR: true
  SELF_HEALING: true

permissions:
  contents: write
  actions: write
  issues: write
  pull-requests: write
  packages: write

jobs:
  autonomous-guardian:
    name: Autonomous Guardian Control
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: Initialize Guardian System
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Setup Guardian Intelligence
        id: intel
        run: |
          echo "🤖 Autonomous Guardian System v${{ env.GUARDIAN_VERSION }} initializing..."
          
          # Create guardian brain
          mkdir -p .guardian/{memory,decisions,actions}
          
          # Load guardian memory
          cat > .guardian/memory/config.json << 'EOF'
          {
            "thresholds": {
              "github_actions": {
                "daily_max": 30,
                "hourly_max": 5,
                "concurrent_max": 3
              },
              "eas": {
                "monthly_max": 5,
                "weekly_max": 2,
                "daily_max": 1
              },
              "alerts": {
                "warning_at": 0.7,
                "critical_at": 0.9,
                "shutdown_at": 1.0
              }
            },
            "protection_levels": {
              "green": "normal",
              "yellow": "caution",
              "orange": "warning",
              "red": "critical",
              "black": "emergency"
            }
          }
          EOF
          
          echo "mode=${{ inputs.mode || 'monitor' }}" >> $GITHUB_OUTPUT
      
      - name: Scan Environment
        id: scan
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "🔍 Scanning environment for threats..."
          
          # Scan all workflows
          TOTAL_WORKFLOWS=$(find .github/workflows -name "*.yml" -o -name "*.yaml" | wc -l)
          ENABLED_WORKFLOWS=$(gh workflow list --all | grep -c "active" || echo 0)
          DISABLED_WORKFLOWS=$(gh workflow list --all | grep -c "disabled" || echo 0)
          
          # Scan for dangerous patterns
          DANGEROUS_PATTERNS=0
          
          # Check for issue triggers in CI workflows
          if grep -r "on:.*issues:" .github/workflows/*.yml 2>/dev/null | grep -v "#"; then
            DANGEROUS_PATTERNS=$((DANGEROUS_PATTERNS + 1))
            echo "⚠️ Found issue triggers in workflows"
          fi
          
          # Check for high-frequency schedules
          if grep -r "cron:.*\*/[0-9]\+.*\*.*\*.*\*" .github/workflows/*.yml 2>/dev/null | grep -E "\*/([1-9]|[1-2][0-9])" | grep -v "#"; then
            DANGEROUS_PATTERNS=$((DANGEROUS_PATTERNS + 1))
            echo "⚠️ Found high-frequency scheduled workflows"
          fi
          
          # Check for missing concurrency controls
          NO_CONCURRENCY=$(grep -L "concurrency:" .github/workflows/*.yml 2>/dev/null | wc -l || echo 0)
          if [[ $NO_CONCURRENCY -gt 0 ]]; then
            DANGEROUS_PATTERNS=$((DANGEROUS_PATTERNS + NO_CONCURRENCY))
            echo "⚠️ Found $NO_CONCURRENCY workflows without concurrency control"
          fi
          
          echo "total_workflows=$TOTAL_WORKFLOWS" >> $GITHUB_OUTPUT
          echo "dangerous_patterns=$DANGEROUS_PATTERNS" >> $GITHUB_OUTPUT
          echo "enabled_workflows=$ENABLED_WORKFLOWS" >> $GITHUB_OUTPUT
      
      - name: Analyze Threats
        id: analyze
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "📊 Analyzing threat level..."
          
          # Get current usage
          RUNS_TODAY=$(gh api repos/${{ github.repository }}/actions/runs \
            --jq '[.workflow_runs[] | select(.created_at > (now - 86400 | todate))] | length')
          
          RUNS_THIS_HOUR=$(gh api repos/${{ github.repository }}/actions/runs \
            --jq '[.workflow_runs[] | select(.created_at > (now - 3600 | todate))] | length')
          
          ACTIVE_RUNS=$(gh run list --status in_progress --json databaseId --jq 'length')
          
          # Calculate threat level
          THREAT_SCORE=0
          THREAT_LEVEL="green"
          
          # Check GitHub Actions
          if [[ $RUNS_TODAY -gt 25 ]]; then
            THREAT_SCORE=$((THREAT_SCORE + 30))
            THREAT_LEVEL="orange"
          elif [[ $RUNS_TODAY -gt 20 ]]; then
            THREAT_SCORE=$((THREAT_SCORE + 20))
            THREAT_LEVEL="yellow"
          fi
          
          if [[ $RUNS_THIS_HOUR -gt 5 ]]; then
            THREAT_SCORE=$((THREAT_SCORE + 40))
            THREAT_LEVEL="red"
          fi
          
          if [[ $ACTIVE_RUNS -gt 3 ]]; then
            THREAT_SCORE=$((THREAT_SCORE + 20))
          fi
          
          # Add pattern threats
          THREAT_SCORE=$((THREAT_SCORE + ${{ steps.scan.outputs.dangerous_patterns }} * 10))
          
          # Determine final threat level
          if [[ $THREAT_SCORE -ge 80 ]]; then
            THREAT_LEVEL="black"
          elif [[ $THREAT_SCORE -ge 60 ]]; then
            THREAT_LEVEL="red"
          elif [[ $THREAT_SCORE -ge 40 ]]; then
            THREAT_LEVEL="orange"
          elif [[ $THREAT_SCORE -ge 20 ]]; then
            THREAT_LEVEL="yellow"
          fi
          
          echo "threat_score=$THREAT_SCORE" >> $GITHUB_OUTPUT
          echo "threat_level=$THREAT_LEVEL" >> $GITHUB_OUTPUT
          echo "runs_today=$RUNS_TODAY" >> $GITHUB_OUTPUT
          echo "runs_hour=$RUNS_THIS_HOUR" >> $GITHUB_OUTPUT
          echo "active_runs=$ACTIVE_RUNS" >> $GITHUB_OUTPUT
      
      - name: Autonomous Decision Engine
        id: decide
        run: |
          echo "🧠 Making autonomous decisions..."
          
          THREAT_LEVEL="${{ steps.analyze.outputs.threat_level }}"
          MODE="${{ steps.intel.outputs.mode }}"
          
          # Decision matrix
          case "$THREAT_LEVEL" in
            black)
              echo "🚨 EMERGENCY PROTOCOL ACTIVATED"
              echo "action=emergency_shutdown" >> $GITHUB_OUTPUT
              ;;
            red)
              echo "⚠️ Critical threat detected"
              echo "action=selective_shutdown" >> $GITHUB_OUTPUT
              ;;
            orange)
              echo "⚠️ Warning level threat"
              echo "action=throttle" >> $GITHUB_OUTPUT
              ;;
            yellow)
              echo "📊 Caution advised"
              echo "action=monitor_closely" >> $GITHUB_OUTPUT
              ;;
            green)
              echo "✅ System nominal"
              echo "action=optimize" >> $GITHUB_OUTPUT
              ;;
          esac
          
          # Override for manual modes
          if [[ "$MODE" == "emergency" ]]; then
            echo "action=emergency_shutdown" >> $GITHUB_OUTPUT
          elif [[ "$MODE" == "repair" ]]; then
            echo "action=auto_repair" >> $GITHUB_OUTPUT
          elif [[ "$MODE" == "reset" ]]; then
            echo "action=reset_system" >> $GITHUB_OUTPUT
          fi
      
      - name: Execute Autonomous Actions
        id: execute
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ACTION="${{ steps.decide.outputs.action }}"
          echo "⚡ Executing action: $ACTION"
          
          case "$ACTION" in
            emergency_shutdown)
              echo "🚨 EMERGENCY SHUTDOWN IN PROGRESS"
              
              # Cancel all workflows
              gh run list --status in_progress --json databaseId \
                --jq '.[].databaseId' | xargs -I {} gh run cancel {} 2>/dev/null || true
              
              # Disable all non-essential workflows
              for workflow in .github/workflows/*.yml; do
                name=$(basename "$workflow")
                if [[ "$name" != "autonomous-guardian.yml" && "$name" != "billing-guardian.yml" ]]; then
                  gh workflow disable "$name" 2>/dev/null || true
                  echo "Disabled: $name"
                fi
              done
              ;;
              
            selective_shutdown)
              echo "🔴 Selective shutdown of dangerous workflows"
              
              # Disable only dangerous workflows
              DANGEROUS=("main.yml" "eas-smart-build.yml" "agent-executor.yml")
              for workflow in "${DANGEROUS[@]}"; do
                if [ -f ".github/workflows/$workflow" ]; then
                  gh workflow disable "$workflow" 2>/dev/null || true
                  echo "Disabled dangerous: $workflow"
                fi
              done
              ;;
              
            throttle)
              echo "🟠 Throttling workflow execution"
              
              # Cancel duplicate runs
              gh run list --status in_progress --json databaseId,name \
                --jq 'group_by(.name) | .[] | select(length > 1) | .[1:] | .[].databaseId' | \
                xargs -I {} gh run cancel {} 2>/dev/null || true
              ;;
              
            auto_repair)
              echo "🔧 Auto-repairing workflows"
              
              # Fix workflows without concurrency
              for workflow in .github/workflows/*.yml; do
                if ! grep -q "concurrency:" "$workflow"; then
                  echo "Adding concurrency to: $workflow"
                  # Would add concurrency block here
                fi
              done
              ;;
              
            optimize)
              echo "🚀 Optimizing system"
              
              # Re-enable safe workflows if they were disabled
              SAFE=("ci-safe.yml" "workflow-monitor.yml" "billing-guardian.yml")
              for workflow in "${SAFE[@]}"; do
                if [ -f ".github/workflows/$workflow" ]; then
                  gh workflow enable "$workflow" 2>/dev/null || true
                fi
              done
              ;;
          esac
          
          echo "action_taken=$ACTION" >> $GITHUB_OUTPUT
      
      - name: Self-Healing Protocol
        if: env.SELF_HEALING == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "🔄 Initiating self-healing protocol..."
          
          # Check if guardian itself is healthy
          GUARDIAN_RUNS=$(gh run list --workflow autonomous-guardian.yml --limit 5 --json conclusion \
            --jq '[.[] | select(.conclusion == "failure")] | length')
          
          if [[ $GUARDIAN_RUNS -gt 2 ]]; then
            echo "⚠️ Guardian system experiencing failures - self-healing..."
            
            # Create self-repair branch
            git checkout -b guardian-self-repair-$(date +%s)
            
            # Fix guardian configuration
            sed -i.bak 's/timeout-minutes: 15/timeout-minutes: 20/' .github/workflows/autonomous-guardian.yml
            
            git add .github/workflows/autonomous-guardian.yml
            git commit -m "🔧 Guardian self-repair: Increase timeout" || true
            git push origin HEAD || true
          fi
      
      - name: Report Status
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create status report
          cat > .guardian/report.md << EOF
          # 🤖 Autonomous Guardian Report
          
          **Time:** $(date -u +"%Y-%m-%d %H:%M UTC")
          **Version:** ${{ env.GUARDIAN_VERSION }}
          
          ## Environment Scan
          - Total Workflows: ${{ steps.scan.outputs.total_workflows }}
          - Enabled: ${{ steps.scan.outputs.enabled_workflows }}
          - Dangerous Patterns: ${{ steps.scan.outputs.dangerous_patterns }}
          
          ## Threat Analysis
          - Threat Level: **${{ steps.analyze.outputs.threat_level }}**
          - Threat Score: ${{ steps.analyze.outputs.threat_score }}/100
          - Runs Today: ${{ steps.analyze.outputs.runs_today }}
          - Runs This Hour: ${{ steps.analyze.outputs.runs_hour }}
          - Active Runs: ${{ steps.analyze.outputs.active_runs }}
          
          ## Action Taken
          - Decision: ${{ steps.decide.outputs.action }}
          - Executed: ${{ steps.execute.outputs.action_taken }}
          
          ## System Status
          - Auto-Repair: ${{ env.AUTO_REPAIR }}
          - Self-Healing: ${{ env.SELF_HEALING }}
          - Guardian Health: Operational
          
          ---
          *This report was generated autonomously by the Guardian System*
          EOF
          
          # Update or create status issue
          STATUS_ISSUE=$(gh issue list --label "guardian-status" --state open --json number --jq '.[0].number')
          
          if [[ -n "$STATUS_ISSUE" ]]; then
            gh issue comment $STATUS_ISSUE --body-file .guardian/report.md
          else
            gh issue create \
              --title "🤖 Autonomous Guardian Status" \
              --label "guardian-status,automated" \
              --body-file .guardian/report.md
          fi
