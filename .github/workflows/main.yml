name: SuperPassword Main Pipeline

on:
  workflow_dispatch: {}
  push:
    branches:
      - develop
      - main
    paths-ignore:
      - "**.md"
      - "docs/**"
  pull_request:
    branches:
      - develop
      - main
    paths-ignore:
      - "**.md"
      - "docs/**"
  schedule:
    - cron: "*/30 * * * *" # Run metrics every 30 minutes
  issues:
    types: [opened, edited, labeled, unlabeled, reopened, assigned, unassigned]
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: write
  pull-requests: write
  security-events: write
  checks: write
  statuses: write
  id-token: write

jobs:
  # Security Analysis
  codeql:
    name: CodeQL
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'pull_request'
    permissions:
      security-events: write
      actions: read
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: github/codeql-action/init@v3
        with:
          languages: javascript
          queries: security-and-quality
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
      - run: |
          npm ci --legacy-peer-deps
          npm run build --if-present
      - uses: github/codeql-action/analyze@v3
        with:
          category: "/language:javascript"

  # Code Validation
  validate:
    name: Validate
    runs-on: ubuntu-latest
    needs: codeql
    if: github.event_name == 'push' || github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.npm
            ~/.expo
          key: ${{ runner.os }}-deps-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-deps-

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Align Expo dependencies
        run: npx expo install --fix --non-interactive || true

      - name: Type check
        run: npx tsc --noEmit

      - name: Lint
        run: |
          npm run lint
          npm run fmt

      - name: Test
        run: npm test -- --coverage

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          fail_ci_if_error: false

      - name: SonarCloud Analysis
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONARCLOUD_TOKEN }}

  # Security Checks
  security:
    name: Security
    runs-on: ubuntu-latest
    needs: validate
    if: github.event_name == 'push' || github.event_name == 'pull_request'
    permissions:
      security-events: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Run OWASP Dependency Check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: "SuperPassword"
          path: "."
          format: "SARIF"
          args: >
            --failOnCVSS 7
            --enableRetired
            --scan ./
            --out ./reports/

      - name: Upload SARIF
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: reports/dependency-check-report.sarif

      - name: Run Snyk
        uses: snyk/actions/node@v0.4.0
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high

  # Project Board and Issue Management
  project-sync:
    name: Project Sync
    runs-on: ubuntu-latest
    # Avoid infinite loops on self-updates and restrict to relevant events
    if: >-
      github.event_name == 'schedule' ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issues' && github.actor != 'github-actions[bot]' && github.event.issue.number != 81) ||
      (github.event_name == 'issue_comment' && github.actor != 'github-actions[bot]')
    concurrency:
      group: project-sync
      cancel-in-progress: true
    env:
      PROJECTS_V2_OWNER: IgorGanapolsky
      PROJECTS_V2_NUMBER: 1
    steps:
      - uses: actions/checkout@v4

      - name: Diagnostics - Projects v2 access
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_PAT || secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const projectOwner = process.env.PROJECTS_V2_OWNER || owner;
            const projectNumber = parseInt(process.env.PROJECTS_V2_NUMBER || '1', 10);
            try {
              const resp = await github.graphql(`
                query($login:String!, $number:Int!){ user(login:$login){ projectV2(number:$number){ id title } } }
              `, { login: projectOwner, number: projectNumber });
              core.info('Projects v2 header OK: ' + JSON.stringify(resp));
            } catch (e) {
              core.warning('Projects v2 header error: ' + (e?.message || String(e)));
              if (e?.errors) core.warning('Errors: ' + JSON.stringify(e.errors));
            }

      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_PAT || secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const projectOwner = process.env.PROJECTS_V2_OWNER || owner;
            const projectNumber = parseInt(process.env.PROJECTS_V2_NUMBER || '1', 10);

            // Guard again inside the script to be extra safe
            try {
              if (context.eventName === 'issues') {
                const num = context?.payload?.issue?.number;
                const actor = context?.actor;
                if (num === 81 || actor === 'github-actions[bot]') {
                  core.info('Skipping self-triggered status issue update run.');
                  return;
                }
              }
            } catch {}

            // Helpers
            function median(nums) {
              if (!nums.length) return 0;
              const s = [...nums].sort((a,b)=>a-b);
              const mid = Math.floor(s.length/2);
              return s.length % 2 ? s[mid] : (s[mid-1]+s[mid])/2;
            }
            function fmtDuration(ms) {
              const sec = Math.floor(ms/1000);
              if (sec < 60) return `${sec}s`;
              const min = Math.floor(sec/60);
              if (min < 60) return `${min}m`;
              const hr = Math.floor(min/60);
              if (hr < 24) return `${hr}h`;
              const day = Math.floor(hr/24);
              if (day < 30) return `${day}d`;
              const mo = Math.floor(day/30);
              if (mo < 12) return `${mo}mo`;
              const yr = Math.floor(mo/12);
              return `${yr}y`;
            }

            // Fetch Projects v2 swimlane counts (Status field) via GraphQL
            async function fetchProjectsV2Swimlanes(login, number) {
              // Get project and discover Status-like field name
              const header = await github.graphql(`
                query($login: String!, $number: Int!) {
                  user(login: $login) {
                    projectV2(number: $number) {
                      id
                      title
                      fields(first: 50) {
                        nodes {
                          __typename
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                          ... on ProjectV2IterationField { id name }
                          ... on ProjectV2Field { id name }
                        }
                      }
                    }
                  }
                }
              `, { login, number });

              const project = header?.user?.projectV2;
              if (!project) return null;

              const statusField = (project.fields.nodes || []).find(f =>
                (f.__typename === 'ProjectV2SingleSelectField') && /status|state/i.test(f.name)
              ) || (project.fields.nodes || []).find(f => f.__typename === 'ProjectV2SingleSelectField');

              const statusFieldName = statusField?.name || 'Status';
              const counts = { todo: 0, inProgress: 0, review: 0, done: 0, other: 0 };

              let hasNextPage = true;
              let after = null;
              while (hasNextPage) {
                const page = await github.graphql(`
                  query($id: ID!, $statusName: String!, $after: String) {
                    node(id: $id) {
                      ... on ProjectV2 {
                        items(first: 100, after: $after) {
                          pageInfo { hasNextPage endCursor }
                          nodes {
                            fieldValueByName(name: $statusName) {
                              __typename
                              ... on ProjectV2ItemFieldSingleSelectValue { name }
                            }
                          }
                        }
                      }
                    }
                  }
                `, { id: project.id, statusName: statusFieldName, after });

                const items = page?.node?.items;
                if (!items) break;

                for (const it of items.nodes) {
                  const val = it.fieldValueByName?.name?.toLowerCase?.() || 'unknown';
                  if (/^to\s*do|backlog|todo$/.test(val)) counts.todo++;
                  else if (/in\s*progress|doing|active/.test(val)) counts.inProgress++;
                  else if (/review|qa|ready\s*for\s*review/.test(val)) counts.review++;
                  else if (/done|closed|complete/.test(val)) counts.done++;
                  else counts.other++;
                }

                hasNextPage = items.pageInfo.hasNextPage;
                after = items.pageInfo.endCursor;
              }

              return { counts, statusFieldName, projectTitle: project.title };
            }

            // Always compute, we update on schedule and events
            const STATUS_ISSUE = 81;
            const allOpenIssues = await github.paginate(github.rest.issues.listForRepo, {
              owner, repo, state: 'open', per_page: 100
            });
            const issues = allOpenIssues.filter(i => !i.pull_request && i.number !== STATUS_ISSUE);
            const openPRs = await github.paginate(github.rest.pulls.list, {
              owner, repo, state: 'open', per_page: 100
            });
            const closedPRs = await github.paginate(github.rest.pulls.list, {
              owner, repo, state: 'closed', per_page: 100
            });

            const now = new Date();
            const last7 = new Date(now.getTime() - 7*24*60*60*1000);
            const last30 = new Date(now.getTime() - 30*24*60*60*1000);

            // Metrics
            const issueCount = issues.length;
            const inProgress = issues.filter(i => (i.assignees?.length || 0) > 0).length;
            const prCount = openPRs.length;
            const bugCount = issues.filter(i => i.labels?.some(l => /\bbug\b/i.test(l.name))).length;
            const featureCount = issues.filter(i => i.labels?.some(l => /(enhancement|feature)/i.test(l.name))).length;

            const activeIssues7 = issues.filter(i => new Date(i.updated_at) >= last7).length;
            const activePRs7 = openPRs.filter(pr => new Date(pr.updated_at) >= last7).length;
            const activityCount = activeIssues7 + activePRs7;
            const totalWork = issueCount + prCount;
            const activityRate = totalWork ? Math.round((activityCount / totalWork) * 100) : 0;

            const mergedLast30 = closedPRs.filter(pr => pr.merged_at && new Date(pr.merged_at) >= last30);
            const throughput = mergedLast30.length;
            const leadTimes = mergedLast30.map(pr => new Date(pr.merged_at) - new Date(pr.created_at));
            const medianLead = median(leadTimes);

            const issueHealth = issueCount > 15 ? '🔴 High' : issueCount > 7 ? '🟡 Medium' : '🟢 Good';
            const prHealth = prCount > 7 ? '🔴 High' : prCount > 3 ? '🟡 Medium' : '🟢 Good';
            const bugHealth = bugCount > 5 ? '🔴 Critical' : bugCount > 2 ? '🟡 Moderate' : '🟢 Low';
            const progressRate = issueCount ? Math.round((inProgress / issueCount) * 100) : 0;
            const progressHealth = progressRate >= 40 ? '🟢 Good' : progressRate >= 20 ? '🟡 Fair' : '🔴 Needs Attention';
            const activityHealth = activityRate >= 50 ? '🟢 High' : activityRate >= 25 ? '🟡 Moderate' : '🔴 Low';

            const recs = [];
            if (issueCount > 15) recs.push('⚠️ High open issue count. Prioritize triage and resolution.');
            if (bugCount > 5) recs.push('🐛 Multiple bugs detected. Focus on stabilization.');
            if (progressRate < 30 && issueCount > 0) recs.push('📈 Low active work rate. Assign/advance more issues.');
            if (activityRate < 25 && totalWork > 0) recs.push('💡 Low activity. Encourage smaller, frequent PRs.');
            if (!recs.length) recs.push('✅ Healthy project indicators. Maintain current velocity.');

            const priorities = issues
              .filter(i => i.labels?.some(l => /^priority:/i.test(l.name)))
              .slice(0, 5)
              .map(i => `- ${i.title} (#${i.number})`);

            const fmtDate = new Date().toLocaleString('en-US', { timeZone: 'America/New_York', dateStyle: 'full', timeStyle: 'medium' });

            // Projects v2 swimlanes (if available)
            let pv2Section = '';
            try {
              const pv2 = await fetchProjectsV2Swimlanes(projectOwner, projectNumber);
              if (pv2) {
                const { counts, statusFieldName, projectTitle } = pv2;
                pv2Section = `\n## 🗂️ Project Board (Projects v2: ${projectTitle})\n\nStatus field: ${statusFieldName}\n\n| To Do | In Progress | Review | Done | Other |\n|---:|---:|---:|---:|---:|\n| ${counts.todo} | ${counts.inProgress} | ${counts.review} | ${counts.done} | ${counts.other} |\n`;
              }
            } catch (e) {
              pv2Section = `\n> Projects v2 data unavailable (${String(e).slice(0,140)}).`;
            }

            const body = `# 📊 SuperPassword Project Status\n\n*Last updated: ${fmtDate}*\n\n## 📈 Current Metrics\n\n| Metric | Count | Status |\n| --- | ---: | --- |\n| 📋 Open Issues | ${issueCount} | ${issueHealth} |\n| 🔧 Open PRs | ${prCount} | ${prHealth} |\n| 🏃 In Progress | ${inProgress} | ${progressRate}% of issues |\n| 🐛 Bugs | ${bugCount} | ${bugHealth} |\n| ✨ Features | ${featureCount} | ${featureCount} planned |\n\n## 🚀 Delivery (last 30 days)\n- Merged PRs: ${throughput}\n- Median PR lead time: ${fmtDuration(medianLead)}\n\n## 📊 Activity (last 7 days)\n- Active items updated: ${activityCount}\n- Activity rate: ${activityRate}% (${activityHealth})\n${pv2Section}\n${priorities.length ? '## 🔝 Top Priorities\n' + priorities.join('\n') + '\n' : ''}\n\n## 🎯 Recommendations\n${recs.map(r => `- ${r}`).join('\n')}\n\n---\n\nAutomation: hourly + on repo events. Manual refresh via local script or rerun workflow.`;

            // Ensure the status issue exists; create if missing, then update
            try {
              await github.rest.issues.get({ owner, repo, issue_number: STATUS_ISSUE });
            } catch (e) {
              await github.rest.issues.create({
                owner, repo,
                title: '📊 SuperPassword Project Status',
                body: 'Initializing status…',
                labels: ['automation', 'metrics', 'status-board']
              });
            }

            await github.rest.issues.update({ owner, repo, issue_number: STATUS_ISSUE, body });

            // For new issues, handle labeling too
            if (context.eventName === 'issues' && context.payload.action === 'opened') {
              const title = context.payload.issue.title.toLowerCase();
              const labels = [];
              if (title.includes('bug') || title.includes('error')) labels.push('type: bug', 'triage');
              else if (title.includes('feature') || title.includes('request')) labels.push('type: enhancement');
              if (labels.length) {
                await github.rest.issues.addLabels({ owner, repo, issue_number: context.payload.issue.number, labels });
              }
            }

  # Build and Deploy
  build:
    name: Build
    needs: [validate, security]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Setup Expo
        uses: expo/expo-github-action@v8
        with:
          eas-version: latest
          token: ${{ secrets.EXPO_TOKEN }}

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Build Development
        if: github.ref == 'refs/heads/develop'
        run: |
          eas build --platform all --profile development --non-interactive

      - name: Build Production
        if: github.ref == 'refs/heads/main'
        run: |
          eas build --platform all --profile production --non-interactive

      - name: Submit to Stores
        if: github.ref == 'refs/heads/main'
        run: |
          eas submit --platform all --latest

  # Notifications
  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [validate, security, build]
    if: always() && (github.event_name == 'push' || github.event_name == 'pull_request')
    steps:
      - name: Notify on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const { repo, owner } = context.repo;
              const run_url = `https://github.com/${owner}/${repo}/actions/runs/${context.runId}`;
              
              const message = `⚠️ CI Pipeline failed for ${context.sha}\nSee details: ${run_url}`;
              
              if (context.payload.pull_request) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: context.payload.pull_request.number,
                  body: message
                });
              }
            } catch (error) {
              console.error('Error creating notification:', error);
            }

      - name: Notify on success
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const { repo, owner } = context.repo;
              const run_url = `https://github.com/${owner}/${repo}/actions/runs/${context.runId}`;
              
              const message = `✅ CI Pipeline passed successfully!\nSee details: ${run_url}`;
              
              if (context.payload.pull_request) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: context.payload.pull_request.number,
                  body: message
                });
              }
            } catch (error) {
              console.error('Error creating notification:', error);
            }
